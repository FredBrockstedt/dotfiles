# -*- mode: snippet -*-
# name: Interacts with webservices
# prefix: uri_snippet
# key: ur
# group: ansible
# --

- name: ${0:Interacts with webservices}
  uri:                                                                     
    url: ${1:HTTP or HTTPS URL in the form (http$$(yas-choose-value '("https)://host}#domain[:port]/path
    dest: ${2:value}                                                       # A path of where to download the file to (if desired)  If I(dest) is a directory, the basename of the file on the remote 
    url_username: ${3:value}                                               # A username for the module to use for Digest, Basic or WSSE authentication 
    url_password: ${4:value}                                               # A password for the module to use for Digest, Basic or WSSE authentication 
    body: ${5:value}                                                       # The body of the http request/response to the web service  If C(body_format) is set to 'json' it will take an already for
    body_format: ${6$$(yas-choose-value '("form-urlencoded" "json" "raw"))}# choices: form-urlencoded;json;raw  The serialization format of the body  When set to C(json) or C(form-urlencoded), enco
    method: ${7:GET}                                                       # The HTTP method of the request or response  In more recent versions we do not restrict the method at the module level an
    return_content: ${8:False}                                             # Whether or not to return the body of the response as a "content" key in the dictionary result  Independently of this opt
    force_basic_auth: ${9:False}                                           # Force the sending of the Basic authentication header upon initial request  The library used by the uri module only sends
    follow_redirects: ${10$$(yas-choose-value '("all" "false" "none" "safe" "urllib2" "true"))}# choices: all;no;none;safe;urllib2;yes  Whether or not the URI module should follow redirects  C(all)
    creates: ${11:value}                                                   # A filename, when it already exists, this step will not be run 
    removes: ${12:value}                                                   # A filename, when it does not exist, this step will not be run 
    status_code: ${13:[200]}                                               # A list of valid, numeric, HTTP status codes that signifies success of the request 
    timeout: ${14:30}                                                      # The socket level timeout in seconds
    headers: ${15:value}                                                   # Add custom HTTP headers to a request in the format of a YAML hash  As of C(2 3) supplying C(Content-Type) here will over
    validate_certs: ${16:True}                                             # If C(no), SSL certificates will not be validated  This should only set to C(no) used on personally controlled sites usin
    client_cert: ${17:value}                                               # PEM formatted certificate chain file to be used for SSL client authentication  This file can also include the key as wel
    client_key: ${18:value}                                                # PEM formatted file that contains your private key to be used for SSL client authentication  If I(client_cert) contains b
    src: ${19:value}                                                       # Path to file to be submitted to the remote server  Cannot be used with I(body) 
    remote_src: ${20:False}                                                # If C(no), the module will search for src on originating/master machine  If C(yes) the module will use the C(src) path on
    force: ${21:False}                                                     # If C(yes) do not get a cached copy  Alias C(thirsty) has been deprecated and will be removed in 2 13 
    use_proxy: ${22:True}                                                  # If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts 
    unix_socket: ${23:value}                                               # Path to Unix domain socket to use for connection
    http_agent: ${24:ansible-httpget}                                      # Header to identify as, generally appears in web server logs 
    mode: ${25:value}                                                      # The permissions the resulting file or directory should have  For those used to I(/usr/bin/chmod) remember that modes are
    owner: ${26:value}                                                     # Name of the user that should own the file/directory, as would be fed to I(chown) 
    group: ${27:value}                                                     # Name of the group that should own the file/directory, as would be fed to I(chown) 
    seuser: ${28:value}                                                    # The user part of the SELinux file context  By default it uses the C(system) policy, where applicable  When set to C(_def
    serole: ${29:value}                                                    # The role part of the SELinux file context  When set to C(_default), it will use the C(role) portion of the policy if ava
    setype: ${30:value}                                                    # The type part of the SELinux file context  When set to C(_default), it will use the C(type) portion of the policy if ava
    selevel: ${31:s0}                                                      # The level part of the SELinux file context  This is the MLS/MCS attribute, sometimes known as the C(range)  When set to 
    unsafe_writes: ${32:False}                                             # Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target file  By default
    attributes: ${33:value}                                                # The attributes the resulting file or directory should have  To get supported flags look at the man page for I(chattr) on
