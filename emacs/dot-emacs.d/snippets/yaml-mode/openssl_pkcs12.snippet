# -*- mode: snippet -*-
# name: Generate OpenSSL PKCS#12 archive
# prefix: openssl_pkcs12_snippet
# key: openssl_pkcs12
# group: ansible
# --

- name: ${0:Generate OpenSSL PKCS#12 archive}
  openssl_pkcs12:                                                          
    path: ${1:Filename to write the PKCS#12 file to}                       #
    action: ${2$$(yas-choose-value '("export" "parse"))}                   # choices: export;parse  C(export) or C(parse) a PKCS#12 
    other_certificates: ${3:value}                                         # List of other certificates to include  Pre 2 8 this parameter was called C(ca_certificates)
    certificate_path: ${4:value}                                           # The path to read certificates and private keys from  Must be in PEM format 
    force: ${5:False}                                                      # Should the file be regenerated even if it already exists 
    friendly_name: ${6:value}                                              # Specifies the friendly name for the certificate and private key 
    iter_size: ${7:2048}                                                   # Number of times to repeat the encryption step 
    maciter_size: ${8:1}                                                   # Number of times to repeat the MAC step 
    passphrase: ${9:value}                                                 # The PKCS#12 password 
    privatekey_passphrase: ${10:value}                                     # Passphrase source to decrypt any input private keys with 
    privatekey_path: ${11:value}                                           # File to read private key from 
    state: ${12$$(yas-choose-value '("absent" "present"))}                 # choices: absent;present  Whether the file should exist or not  All parameters except C(path) are ignored when state is C
    src: ${13:value}                                                       # PKCS#12 file path to parse 
    backup: ${14:False}                                                    # Create a backup file including a timestamp so you can get the original output file back if you overwrote it with a new o
    mode: ${15:value}                                                      # The permissions the resulting file or directory should have  For those used to I(/usr/bin/chmod) remember that modes are
    owner: ${16:value}                                                     # Name of the user that should own the file/directory, as would be fed to I(chown) 
    group: ${17:value}                                                     # Name of the group that should own the file/directory, as would be fed to I(chown) 
    seuser: ${18:value}                                                    # The user part of the SELinux file context  By default it uses the C(system) policy, where applicable  When set to C(_def
    serole: ${19:value}                                                    # The role part of the SELinux file context  When set to C(_default), it will use the C(role) portion of the policy if ava
    setype: ${20:value}                                                    # The type part of the SELinux file context  When set to C(_default), it will use the C(type) portion of the policy if ava
    selevel: ${21:s0}                                                      # The level part of the SELinux file context  This is the MLS/MCS attribute, sometimes known as the C(range)  When set to 
    unsafe_writes: ${22:False}                                             # Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target file  By default
    attributes: ${23:value}                                                # The attributes the resulting file or directory should have  To get supported flags look at the man page for I(chattr) on
