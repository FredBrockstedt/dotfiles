# -*- mode: snippet -*-
# name: Deploy software (or files) from git checkouts
# prefix: git_snippet
# key: git
# group: ansible
# --

- name: ${0:Deploy software (or files) from git checkouts}
  git:                                                                     
    repo: ${1:git, SSH, or HTTP(S) protocol address of the git repository} #
    dest: ${2:The path of where the repository should be checked out}      # This parameter is required, unless C(clone) is set to C(no) 
    version: ${3:HEAD}                                                     # What version of the repository to check out   This can be the literal string C(HEAD), a branch name, a tag name  It can 
    accept_hostkey: ${4:false}                                             # if C(yes), ensure that "-o StrictHostKeyChecking=no" is present as an ssh option 
    ssh_opts: ${5:value}                                                   # Creates a wrapper script and exports the path as GIT_SSH which git then automatically uses to override ssh arguments  An
    key_file: ${6:value}                                                   # Specify an optional private key file path, on the target host, to use for the checkout 
    reference: ${7:value}                                                  # Reference repository (see "git clone --reference    ")
    remote: ${8:origin}                                                    # Name of the remote 
    refspec: ${9:value}                                                    # Add an additional refspec to be fetched  If version is set to a I(SHA-1) not reachable from any branch or tag, this opti
    force: ${10:false}                                                     # If C(yes), any modified files in the working repository will be discarded   Prior to 0 7, this was always 'yes' and coul
    depth: ${11:value}                                                     # Create a shallow clone with a history truncated to the specified number or revisions  The minimum possible value is C(1)
    clone: ${12:true}                                                      # If C(no), do not clone the repository even if it does not exist locally
    update: ${13:true}                                                     # If C(no), do not retrieve new revisions from the origin repository Operations like archive will work on the existing (ol
    executable: ${14:value}                                                # Path to git executable to use  If not supplied, the normal mechanism for resolving binary paths will be used 
    bare: ${15:false}                                                      # if C(yes), repository will be created as a bare repo, otherwise it will be a standard repo with a workspace 
    umask: ${16:value}                                                     # The umask to set before doing any checkouts, or any other repository maintenance 
    recursive: ${17:true}                                                  # if C(no), repository will be cloned without the --recursive option, skipping sub-modules 
    track_submodules: ${18:false}                                          # if C(yes), submodules will track the latest commit on their master branch (or other branch specified in  gitmodules)   I
    verify_commit: ${19:false}                                             # if C(yes), when cloning or checking out a C(version) verify the signature of a GPG signed commit  This requires C(git) v
    archive: ${20:value}                                                   # Specify archive file path with extension  If specified, creates an archive file of the specified format containing the t
    separate_git_dir: ${21:value}                                          # The path to place the cloned repository  If specified, Git repository can be separated from working tree 
    gpg_whitelist: ${22:[]}                                                # A list of trusted GPG fingerprints to compare to the fingerprint of the GPG-signed commit  Only used when I(verify_commi
