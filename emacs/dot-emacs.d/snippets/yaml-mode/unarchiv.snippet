# -*- mode: snippet -*-
# name: Unpacks an archive after (optionally) copying it from the local machine.
# prefix: unarchive_snippet
# key: unarchiv
# group: ansible
# --

- name: ${0:Unpacks an archive after (optionally) copying it from the local machine.}
  unarchive:                                                               
    src: ${1:If C(remote_src=no) (default), local path to archive file to copy to the target server; can be absolute or relative}# If C(remote_src=yes), path on the target server to existing archiv
    dest: ${2:Remote absolute path where the archive should be unpacked}   #
    copy: ${3:True}                                                        # If true, the file is copied from local 'master' to the target machine, otherwise, the plugin will look for src archive a
    creates: ${4:value}                                                    # If the specified absolute path (file or directory) already exists, this step will B(not) be run 
    list_files: ${5:False}                                                 # If set to True, return the list of files that are contained in the tarball 
    exclude: ${6:value}                                                    # List the directory and file entries that you would like to exclude from the unarchive action 
    keep_newer: ${7:False}                                                 # Do not replace existing files that are newer than files from the archive 
    extra_opts: ${8:}                                                      # Specify additional options by passing in an array  Each space-separated command-line option should be a new element of t
    remote_src: ${9:False}                                                 # Set to C(yes) to indicate the archived file is already on the remote system and not local to the Ansible controller  Thi
    validate_certs: ${10:True}                                             # This only applies if using a https URL as the source of the file  This should only set to C(no) used on personally contr
    decrypt: ${11:True}                                                    # This option controls the autodecryption of source files using vault 
    mode: ${12:value}                                                      # The permissions the resulting file or directory should have  For those used to I(/usr/bin/chmod) remember that modes are
    owner: ${13:value}                                                     # Name of the user that should own the file/directory, as would be fed to I(chown) 
    group: ${14:value}                                                     # Name of the group that should own the file/directory, as would be fed to I(chown) 
    seuser: ${15:value}                                                    # The user part of the SELinux file context  By default it uses the C(system) policy, where applicable  When set to C(_def
    serole: ${16:value}                                                    # The role part of the SELinux file context  When set to C(_default), it will use the C(role) portion of the policy if ava
    setype: ${17:value}                                                    # The type part of the SELinux file context  When set to C(_default), it will use the C(type) portion of the policy if ava
    selevel: ${18:s0}                                                      # The level part of the SELinux file context  This is the MLS/MCS attribute, sometimes known as the C(range)  When set to 
    unsafe_writes: ${19:False}                                             # Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target file  By default
    attributes: ${20:value}                                                # The attributes the resulting file or directory should have  To get supported flags look at the man page for I(chattr) on
