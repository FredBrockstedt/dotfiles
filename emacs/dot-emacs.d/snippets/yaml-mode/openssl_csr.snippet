# -*- mode: snippet -*-
# name: Generate OpenSSL Certificate Signing Request (CSR)
# prefix: openssl_csr_snippet
# key: openssl_csr
# group: ansible
# --

- name: ${0:Generate OpenSSL Certificate Signing Request (CSR)}
  openssl_csr:                                                             
    path: ${1:The name of the file into which the generated OpenSSL certificate signing request will be written}#
    state: ${2$$(yas-choose-value '("absent" "present"))}                  # choices: absent;present  Whether the certificate signing request should exist or not, taking action if the state is diff
    digest: ${3:sha256}                                                    # The digest used when signing the certificate signing request with the private key 
    privatekey_path: ${4:value}                                            # The path to the private key to use when signing the certificate signing request  Required if I(state) is C(present) 
    privatekey_passphrase: ${5:value}                                      # The passphrase for the private key  This is required if the private key is password protected 
    version: ${6:1}                                                        # The version of the certificate signing request  The only allowed value according to L(RFC 2986,https://tools ietf org/ht
    force: ${7:False}                                                      # Should the certificate signing request be forced regenerated by this ansible module 
    subject: ${8:value}                                                    # Key/value pairs that will be present in the subject name field of the certificate signing request  If you need to specif
    country_name: ${9:value}                                               # The countryName field of the certificate signing request subject 
    state_or_province_name: ${10:value}                                    # The stateOrProvinceName field of the certificate signing request subject 
    locality_name: ${11:value}                                             # The localityName field of the certificate signing request subject 
    organization_name: ${12:value}                                         # The organizationName field of the certificate signing request subject 
    organizational_unit_name: ${13:value}                                  # The organizationalUnitName field of the certificate signing request subject 
    common_name: ${14:value}                                               # The commonName field of the certificate signing request subject 
    email_address: ${15:value}                                             # The emailAddress field of the certificate signing request subject 
    subject_alt_name: ${16:value}                                          # SAN extension to attach to the certificate signing request  This can either be a 'comma separated string' or a YAML list
    subject_alt_name_critical: ${17:value}                                 # Should the subjectAltName extension be considered as critical 
    use_common_name_for_san: ${18:True}                                    # If set to C(yes), the module will fill the common name in for C(subject_alt_name) with C(DNS:) prefix if no SAN is speci
    key_usage: ${19:value}                                                 # This defines the purpose (e g  encipherment, signature, certificate signing) of the key contained in the certificate 
    key_usage_critical: ${20:value}                                        # Should the keyUsage extension be considered as critical 
    extended_key_usage: ${21:value}                                        # Additional restrictions (e g  client authentication, server authentication) on the allowed purposes for which the public
    extended_key_usage_critical: ${22:value}                               # Should the extkeyUsage extension be considered as critical 
    basic_constraints: ${23:value}                                         # Indicates basic constraints, such as if the certificate is a CA 
    basic_constraints_critical: ${24:value}                                # Should the basicConstraints extension be considered as critical 
    ocsp_must_staple: ${25:value}                                          # Indicates that the certificate should contain the OCSP Must Staple extension (U(https://tools ietf org/html/rfc7633)) 
    ocsp_must_staple_critical: ${26:value}                                 # Should the OCSP Must Staple extension be considered as critical Note that according to the RFC, this extension should no
    select_crypto_backend: ${27$$(yas-choose-value '("auto" "cryptography" "pyopenssl"))}# choices: auto;cryptography;pyopenssl  Determines which crypto backend to use  The default choice is C(auto
    backup: ${28:False}                                                    # Create a backup file including a timestamp so you can get the original CSR back if you overwrote it with a new one by ac
    create_subject_key_identifier: ${29:False}                             # Create the Subject Key Identifier from the public key  Please note that commercial CAs can ignore the value, respectivel
    subject_key_identifier: ${30:value}                                    # The subject key identifier as a hex string, where two bytes are separated by colons  Example: C(00:11:22:33:44:55:66:77:
    authority_key_identifier: ${31:value}                                  # The authority key identifier as a hex string, where two bytes are separated by colons  Example: C(00:11:22:33:44:55:66:7
    authority_cert_issuer: ${32:value}                                     # Names that will be present in the authority cert issuer field of the certificate signing request  Values must be prefixe
    authority_cert_serial_number: ${33:value}                              # The authority cert serial number  Note that this is only supported if the C(cryptography) backend is used! Please note t
    mode: ${34:value}                                                      # The permissions the resulting file or directory should have  For those used to I(/usr/bin/chmod) remember that modes are
    owner: ${35:value}                                                     # Name of the user that should own the file/directory, as would be fed to I(chown) 
    group: ${36:value}                                                     # Name of the group that should own the file/directory, as would be fed to I(chown) 
    seuser: ${37:value}                                                    # The user part of the SELinux file context  By default it uses the C(system) policy, where applicable  When set to C(_def
    serole: ${38:value}                                                    # The role part of the SELinux file context  When set to C(_default), it will use the C(role) portion of the policy if ava
    setype: ${39:value}                                                    # The type part of the SELinux file context  When set to C(_default), it will use the C(type) portion of the policy if ava
    selevel: ${40:s0}                                                      # The level part of the SELinux file context  This is the MLS/MCS attribute, sometimes known as the C(range)  When set to 
    unsafe_writes: ${41:False}                                             # Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target file  By default
    attributes: ${42:value}                                                # The attributes the resulting file or directory should have  To get supported flags look at the man page for I(chattr) on
